<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Miles Waite</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <style>
        /* Reset & basics */
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 1.5s ease, color 1.5s ease;
        }

        :root {
            --bg-black: #000;
            --bg-white: #fff;
            --text-white: #fff;
            --text-black: #000;
            --yellow-bright: #fff822;
            --blue-bright: #2288ff;
            --red-bright: #ff2222;
        }

        /* Theme variables set by JS */
        body.black-theme {
            --bg-color: var(--bg-black);
            --text-color: var(--text-white);
        }
        body.white-theme {
            --bg-color: var(--bg-white);
            --text-color: var(--text-black);
        }

        header {
            display: flex;
            justify-content: center;
            gap: 3rem;
            padding: 1.5rem 0;
            font-weight: 700;
            font-size: 1.25rem;
            user-select: none;
            letter-spacing: 0.08em;
        }

        header div {
            cursor: pointer;
            position: relative;
            padding-bottom: 4px;
        }
        header div::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 3px;
            background: currentColor;
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.3s ease;
        }
        header div:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* Container for canvas */
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: fadeIn 2s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<header>
    <div>Projects.</div>
    <div>Music.</div>
    <div>Code.</div>
    <div>Links.</div>
</header>

<div id="canvas-container"></div>

<script>
    // Randomly pick theme on load
    const isBlackTheme = Math.random() < 0.5;
    document.body.classList.add(isBlackTheme ? 'black-theme' : 'white-theme');

    // p5 sketch inside container
    let angle = 0;
    let innerColorCycle = 0; // from 0 to TWO_PI

    const canvasContainer = document.getElementById('canvas-container');

    new p5((p) => {
        p.setup = function() {
            p.createCanvas(600, 600, p.WEBGL).parent(canvasContainer);
            p.noFill();
            p.strokeWeight(2);
        };

        p.draw = function() {
            // Background color from CSS var for smooth transition consistency
            p.background(getComputedStyle(document.body).getPropertyValue('--bg-color').trim());

            // Camera setup
            const camRadius = 850;
            const camX = p.cos(angle * 0.3) * camRadius;
            const camY = -100;
            const camZ = p.sin(angle * 0.3) * camRadius;
            p.camera(camX, camY, camZ, 0, 0, 0, 0, 1, 0);

            // Outer cube: pure white always
            p.push();
            p.stroke(isBlackTheme ? 255 : 0, isBlackTheme ? 255 : 0, isBlackTheme ? 255 : 0);
            p.rotateX(angle * 0.5);
            p.rotateY(angle);
            drawCube(p, 200);
            p.pop();

            // Inner cube colors depend on theme
            p.push();
            p.rotateX(-angle * 0.8);
            p.rotateZ(angle * 0.3);

            // Cycle inner cube color smoothly
            innerColorCycle += 0.01;
            if (innerColorCycle > p.TWO_PI) innerColorCycle = 0;

            let innerStroke;
            if (isBlackTheme) {
                // Cycle: white → red → blue
                // Use sin/cos waves for smooth transition
                const r = 255;
                const g = 0;
                const b = 0;

                // Using a sine wave to blend colors over TWO_PI
                // white to red to blue, cycle
                const phase = innerColorCycle;

                // Map phase [0, 2PI] to blend colors
                // We'll blend white (255,255,255) to red(255,0,0) to blue(0,0,255)
                // Split into 3 phases:
                // 0 to 2PI/3 : white to red
                // 2PI/3 to 4PI/3 : red to blue
                // 4PI/3 to 2PI : blue to white

                let rC, gC, bC;
                if (phase < p.TWO_PI / 3) {
                    // white to red
                    const t = phase / (p.TWO_PI / 3);
                    rC = 255;
                    gC = 255 * (1 - t);
                    bC = 255 * (1 - t);
                } else if (phase < (2 * p.TWO_PI) / 3) {
                    // red to blue
                    const t = (phase - p.TWO_PI / 3) / (p.TWO_PI / 3);
                    rC = 255 * (1 - t);
                    gC = 0;
                    bC = 255 * t;
                } else {
                    // blue to white
                    const t = (phase - (2 * p.TWO_PI) / 3) / (p.TWO_PI / 3);
                    rC = 255 * t;
                    gC = 255 * t;
                    bC = 255;
                }
                innerStroke = p.color(rC, gC, bC);
            } else {
                // White bg theme: black → bright yellow → bright blue

                const phase = innerColorCycle;
                // black(0,0,0) to yellow(255,248,34) to blue(34,136,255)
                // same 3 phases cycle as above

                let rC, gC, bC;
                const yellow = {r:255, g:248, b:34};
                const blue = {r:34, g:136, b:255};

                if (phase < p.TWO_PI / 3) {
                    // black to yellow
                    const t = phase / (p.TWO_PI / 3);
                    rC = yellow.r * t;
                    gC = yellow.g * t;
                    bC = yellow.b * t;
                } else if (phase < (2 * p.TWO_PI) / 3) {
                    // yellow to blue
                    const t = (phase - p.TWO_PI / 3) / (p.TWO_PI / 3);
                    rC = yellow.r + (blue.r - yellow.r) * t;
                    gC = yellow.g + (blue.g - yellow.g) * t;
                    bC = yellow.b + (blue.b - yellow.b) * t;
                } else {
                    // blue to black
                    const t = (phase - (2 * p.TWO_PI) / 3) / (p.TWO_PI / 3);
                    rC = blue.r * (1 - t);
                    gC = blue.g * (1 - t);
                    bC = blue.b * (1 - t);
                }
                innerStroke = p.color(rC, gC, bC);
            }

            p.stroke(innerStroke);
            drawCube(p, 80);
            p.pop();

            angle += 0.01;
        };

        function drawCube(p, size) {
            let points = [];
            for (let x = -1; x <= 1; x += 2) {
                for (let y = -1; y <= 1; y += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        points.push(p.createVector(x, y, z).mult(size / 2));
                    }
                }
            }

            // Draw edges
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const d = p5.Vector.sub(points[i], points[j]).mag();
                    if (Math.abs(d - size) < 0.1) {
                        p.line(points[i].x, points[i].y, points[i].z,
                            points[j].x, points[j].y, points[j].z);
                    }
                }
            }
        }
    });
</script>
</body>
</html>
